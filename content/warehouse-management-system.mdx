---
title: "Spreadsheet driven Warehouse Management System"
abstract: I decided to share the results even though it may not be the best representation of webdev skills, as it does not involve complex solution. This project represents a complete process of solving a practical problem, from defining the problem, coming up with the most appropriate solution, designing the process, to implementing the software. It is a one-person complete process of completing a task on a micro scale.
publishedOn: "2024-10-09T23:34:37+0200"
---

<Tag
  github={"https://github.com/olgierdkrzyzaniak/IMSPlastwil"}
  github_title={"WarehouseManagementSystem"}
>
  {["Python", "tkinter", "openpyxl"]}
</Tag>

## Why is this project included in the portfolio?

Some time ago, one of my friends asked me if I could help improve the warehouse management for the company he works at. It come down to keep track of the quantity of parts in the warehouse, when and by whom they are taken/returned, and the usage rates on specific days.

I decided to share the results even though it may not be the best representation of webdev skills, as it does not involve complex solutions. Python even is not my main language - but that was intentional and has its reasoning (explained below). This project represents a complete process of solving a practical problem, from defining the problem, coming up with the most appropriate solution, designing the process, to implementing the software. It is a one-person complete process of completing a task on a micro scale.

## Design Process

I wondered how to design the entire process to be as quick and as least annoying as possible for the employees (who previously took everything without any record-keeping) while still providing the company with all the necessary data. Since this was a grassroots initiative, it would also be beneficial if the solution did not incur additional costs for the company (making it easier to persuade management to implement such a solution).

After a few unsuccessful ideas (which aimed to use Power Apps or Retool but these tools would require subscriptions and more expensive equipment for their functionality), I came up with a solution that I intended to write in Python. I chose this language instead of JavaScript (which is my main language) due to the familiarity of the company's employees with Python. Python does not require a browser to run, and the .exe files generated by Node.js would be heavy.

I designed the entire process of taking and returning parts using a simple barcode scanner (which was probably the fastest way to input data into a computer from the available options). The process diagram is below:

![Scheme](/Scheme.png)

Everything was to be stored in Excel sheets. This was to be the main data source. This allowed for easy viewing and potential editing by moderately technical people. I decided to divide one database file into three sheets. The first sheet contained employee data, the second one contained product data, and the third one was to be the register of operations (taking and returning items).

## What was difficult for me?

If we look at the code, the program consists of two classes with numerous methods. One class is responsible for handling the database, and the other for the application's functionality (displaying the interface, manipulating the application state).

There is actually nothing very difficult in the code itself, but the complexity of the project still exceeded my initial expectations. Several times, I had to add error handling so that the user wouldn’t hit a dead end. For example, how the system should behave when the user does not enter the employee code before scanning the product, or what to do when the user does not confirm everything by scanning the employee code again (solutions in the `submit_action` function).

It also took me a relatively long time to figure out how to make the summary table “dynamic,” meaning that when we add a product already in the table, it doesn’t appear as the next record but updates the quantity of the existing one, and if the quantity equals zero, it disappears from the table.

```python
def update_table_record(self, item_id, user_id, product_id, quantity, date):
        current_quantity = int(self.tree.item(item_id, "values")[3])
        updated_quantity = current_quantity + quantity

        # Update the quantity, activity, and user ID in the table
        self.tree.item(
            item_id,
            values=(
                item_id,
                user_id,
                product_id,
                updated_quantity,
                "Take Product" if updated_quantity < 0 else "Return Product",
                date,
            ),
        )

        # Remove the record if the quantity becomes zero
        if updated_quantity == 0:
            self.tree.delete(item_id)
```

State similar to HATOS. Initially, I wanted to program a state object, but updating it this way was extremely cumbersome and, when implemented, caused errors which I couldn't explain, so I made the table itself the source of state.

Before starting, I didn’t know how a barcode scanner would interact with the computer since I had never used one before. However, a quick YouTube search showed that it literally types the text assigned to the code and presses "Enter."

The graphical interface is not the most beautiful, but it provides all the necessary information, facilitating the use of the program. It is also very clear and was quick (and concise) to write. Screenshot below:

![/UI_screen.png](/UI_screen.png)

Then I was asked to replace the scanning of the employee card with the requirement for the user to log in to their Microsoft account, from which the user's data would be retrieved. Personally, I consider this very impractical and cumbersome, significantly lengthening the process, but these were the security requirements of the company.

Below is the code that provided the program with data:

```python
def get_display_name():
    GetUserNameEx = ctypes.windll.secur32.GetUserNameExW
    NameDisplay = 3

    size = ctypes.pointer(ctypes.c_ulong(0))
    GetUserNameEx(NameDisplay, None, size)

    nameBuffer = ctypes.create_unicode_buffer(size.contents.value)
    GetUserNameEx(NameDisplay, nameBuffer, size)
    return nameBuffer.value
```

I also learned that it's worth having the actual decision-maker involved in the process from the very beginning.

I tried to include numerous comments in the code so that anyone who wants to make changes/improvements in the future will have no trouble navigating it. I usually don't leave comments because I believe the code should speak for itself, except in cases of non-standard uses where I justify the use of a tool for my future reference.
